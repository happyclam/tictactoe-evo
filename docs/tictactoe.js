// Generated by CoffeeScript 1.12.2
(function() {
  var Board, Const, Game, Player, Tree,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  (function(jQuery) {
    var $;
    $ = jQuery;
    return $.fn.pointer = function(settings) {
      var defaultConfig, options;
      defaultConfig = {
        target: '#canvasMain'
      };
      options = $.extend(defaultConfig, settings);
      this.each(function() {
        var me;
        me = $(this);
        me.css({
          'position': 'relative'
        });
        $(options.target).click(function(e) {
          var clickX, clickY, locate, pos, radius, x, y;
          clickX = Math.floor(e.offsetX / options.divide);
          clickY = Math.floor(e.offsetY / options.divide);
          locate = clickX + clickY * 3;
          radius = options.divide / 2;
          x = (options.divide * (locate % 3)) + radius + e.currentTarget.offsetLeft;
          y = (options.divide * Math.floor(locate / 3)) + radius + e.currentTarget.offsetTop;
          pos = {
            top: y - radius,
            left: x - radius,
            height: options.divide * 0.9,
            width: options.divide * 0.9
          };
          me.append('<div class="ripple"></div>');
          me.find('.ripple:last').css({
            'position': 'absolute',
            'z-index': 9999,
            'height': pos.height,
            'width': pos.width,
            'border': 'solid 4px #ccc',
            'opacity': 0.3,
            'background': '#ccc'
          }).css({
            'top': pos.top,
            'left': pos.left
          }).animate({
            'height': 1,
            'width': 1,
            'left': x - 5,
            'top': y - 5
          }, {
            duration: 300,
            queue: false
          }).fadeOut(500, function() {
            $(this).remove();
          });
        });
      });
    };
  })(jQuery);

  $(function() {
    var Tictactoe;
    return Tictactoe = new Game;
  });

  Tree = (function() {
    var idx, overlapped, reach;

    Tree.counter = 0;

    Tree.total = 0;

    Tree.pebbles = 0;

    function Tree(v, score) {
      if (score == null) {
        score = [];
      }
      this.value = v;
      this.child = [];
      this.score = score.length === 0 ? this.makescore(v) : score;
    }

    Tree.deserialize = function(src) {
      var b, i, j, len, node, ref, root;
      root = new Tree(new Board(src.value, src.value.teban, src.value.move), src.score);
      ref = src.child;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        b = ref[i];
        node = new Tree(new Board(b.value, b.value.teban, b.value.move), b.score);
        root.child.push(node);
        this.build(node, b);
      }
      return root;
    };

    Tree.build = function(parent, src) {
      var c, j, len, node, ref, results;
      ref = src.child;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        node = new Tree(new Board(c.value, c.value.teban, c.value.move), c.score);
        parent.child.push(node);
        results.push(this.build(node, c));
      }
      return results;
    };

    Tree.prototype.count = function(v) {
      var j, len, o, ref;
      ref = this.child;
      for (j = 0, len = ref.length; j < len; j++) {
        o = ref[j];
        if (o.value.toString() === v.toString()) {
          Tree.counter += 1;
        } else {
          Tree.counter = o.count(v);
        }
      }
      return Tree.counter;
    };

    Tree.prototype.makescore = function(board) {
      var i, j, k, len, score;
      score = board.slice(0, board.length);
      for (i = j = 0, len = score.length; j < len; i = ++j) {
        k = score[i];
        if (k != null) {
          score[i] = null;
        } else {
          score[i] = Const.PEBBLES;
        }
      }
      return score;
    };

    Tree.prototype.show = function() {
      var c, j, len, ref, results;
      ref = this.child;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        results.push(c.show());
      }
      return results;
    };

    Tree.prototype.add = function(target, obj) {
      var i, j, k, len, ref, ret;
      ret = null;
      ref = this.child;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        k = ref[i];
        if (k.value.toString() === target.toString()) {
          ret = k.child.push(obj);
        } else {
          ret = k.add(target, obj);
        }
        if (ret != null) {
          break;
        }
      }
      return ret;
    };

    Tree.prototype.apply = function(v) {
      var c, converted, i, j, len, ref, ret, temp;
      if (this.value.toString() === v.toString()) {
        return idx.call(this, this.score);
      }
      ret = null;
      ref = this.child;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        c = ref[i];
        converted = overlapped.call(this, v, c.value);
        if (converted != null) {
          temp = idx.call(this, c.score);
          ret = Board.rotate_sym[converted][temp];
        } else {
          ret = c.apply(v);
        }
        if (ret != null) {
          break;
        }
      }
      return ret;
    };

    Tree.prototype.search = function(v) {
      var c, converted, j, len, ref, ret;
      if (v == null) {
        return null;
      }
      converted = 0;
      if (this.value.toString() === v.toString()) {
        return [this, converted];
      }
      ret = null;
      ref = this.child;
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        converted = overlapped.call(this, v, c.value);
        if (converted != null) {
          ret = [c, converted];
        } else {
          ret = c.search(v);
        }
        if (ret != null) {
          break;
        }
      }
      return ret;
    };

    Tree.prototype.statistics_prevent = function() {
      var c, j, len, ref, ret, temp;
      ref = this.child;
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        ret = [];
        ret = reach.call(this, c.value);
        if (ret[0] === Const.CROSS || ret[0] === Const.NOUGHT) {
          temp = c.score.reduce(function(t, s) {
            return t + s;
          });
          Tree.total = Tree.total + temp;
          Tree.pebbles = Tree.pebbles + c.score[ret[1]];
        } else {
          ret = c.statistics_prevent();
        }
      }
      return [Tree.total, Tree.pebbles];
    };

    overlapped = function(src, dest) {
      var buf, i, j, l, len, len1, m, ref, temp, v, value;
      temp = dest.clone();
      ref = Board.rotate_sym;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        v = ref[i];
        buf = new Array(Const.BOARD_SIZE);
        for (l = m = 0, len1 = temp.length; m < len1; l = ++m) {
          value = temp[l];
          buf[v[l]] = value;
        }
        if (buf.toString() === src.toString()) {
          return i;
        }
      }
      return null;
    };

    reach = function(board) {
      var cross_reach, i, j, l, len, locate, nought_reach, piece, ref;
      locate = null;
      ref = Board.lines;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        l = ref[i];
        piece = this[l[0]];
        if (piece && piece === board[l[1]] && piece === board[l[2]]) {
          cross_reach = false;
          nought_reach = false;
          locate = null;
          break;
        } else {
          switch (board.teban) {
            case Const.NOUGHT:
              if (board[l[0]] === Const.CROSS && board[l[1]] === Const.CROSS && board[l[2]] === null) {
                cross_reach = true;
                locate = l[2];
              } else if (board[l[0]] === null && board[l[1]] === Const.CROSS && board[l[2]] === Const.CROSS) {
                cross_reach = true;
                locate = l[0];
              } else if (board[l[0]] === Const.CROSS && board[l[1]] === null && board[l[2]] === Const.CROSS) {
                cross_reach = true;
                locate = l[1];
              }
              break;
            case Const.CROSS:
              if (board[l[0]] === Const.NOUGHT && board[l[1]] === Const.NOUGHT && board[l[2]] === null) {
                nought_reach = true;
                locate = l[2];
              } else if (board[l[0]] === null && board[l[1]] === Const.NOUGHT && board[l[2]] === Const.NOUGHT) {
                nought_reach = true;
                locate = l[0];
              } else if (board[l[0]] === Const.NOUGHT && board[l[1]] === null && board[l[2]] === Const.NOUGHT) {
                nought_reach = true;
                locate = l[1];
              }
              break;
            default:
              console.log("=== error ===");
          }
        }
      }
      if (cross_reach) {
        return [Const.CROSS, locate];
      } else if (nought_reach) {
        return [Const.NOUGHT, locate];
      } else {
        return [Const.ONGOING, locate];
      }
    };

    idx = function(score) {
      var i, index, j, len, ret, start, v;
      ret = null;
      index = ((Math.random() * score.reduce(function(t, s) {
        return t + s;
      })) * 10) / 10.0;
      start = 0;
      for (i = j = 0, len = score.length; j < len; i = ++j) {
        v = score[i];
        if (!v) {
          continue;
        }
        start += v;
        if (start > index) {
          ret = i;
          break;
        }
      }
      return ret;
    };

    return Tree;

  })();

  Const = (function() {
    function Const() {}

    Const.NOUGHT = 1;

    Const.CROSS = -1;

    Const.DRAW = 0;

    Const.BOARD_SIZE = 9;

    Const.ONGOING = 999;

    Const.MAX_VALUE = 9;

    Const.MIN_VALUE = -9;

    Const.LINE_WIDTH = 8;

    Const.RED_LINE_WIDTH = 14;

    Const.PEBBLES = 1.0;

    Const.ALL_NODES = 627;

    Const.DATA_READ_ERROR = "学習データが壊れています。初期化が必要です。";

    Const.DATA_ERROR = "学習データが壊れています。「データを消去」を試して下さい。";

    Const.DATA_LEARN_WRITE_ERROR = "学習データの書き込みに失敗しました。";

    Const.DATA_DUP_WRITE_ERROR = "重複チェックデータの書き込みに失敗しました。";

    Const.DATA_NO_NODE = "データが見つかりません。";

    Const.IMG_ALT = "進化度合い";

    Const.IMG_INDEX = "SpriteSheet";

    Const.IMG_SEED = "fancySerialNo";

    Const.INITIALIZING_MSG = "Data Initializing...";

    Const.RESTART_MSG = "Restart please!";

    return Const;

  })();

  Board = (function(superClass) {
    var drawanimation;

    extend(Board, superClass);

    Board.restore_table = [0, 3, 2, 1, 4, 5, 6, 7];

    Board.rotate_sym = [[0, 1, 2, 3, 4, 5, 6, 7, 8], [2, 5, 8, 1, 4, 7, 0, 3, 6], [8, 7, 6, 5, 4, 3, 2, 1, 0], [6, 3, 0, 7, 4, 1, 8, 5, 2], [2, 1, 0, 5, 4, 3, 8, 7, 6], [6, 7, 8, 3, 4, 5, 0, 1, 2], [0, 3, 6, 1, 4, 7, 2, 5, 8], [8, 5, 2, 7, 4, 1, 6, 3, 0]];

    Board.lines = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]];

    Board.lineno = null;

    Board.canvas = null;

    Board.request = null;

    Board.amount = 0;

    Board.divide = 0;

    Board.radius = 0;

    Board.statusarea = null;

    Board.animate = function() {
      Board.request = requestAnimFrame(Board.animate, Board.canvas);
      return drawanimation.call(Board);
    };

    drawanimation = function() {
      var context, ended, newX, newY, start;
      start = {
        y: 0,
        x: 0
      };
      ended = {
        y: 0,
        x: 0
      };
      context = Board.canvas.getContext('2d');
      Board.amount += 0.02;
      if (Board.amount > 1) {
        Board.amount = 1;
      }
      switch (Board.lineno) {
        case 0:
          start.x = 25;
          start.y = Math.floor(Board.divide / 2);
          ended.x = Board.canvas.width - 25;
          ended.y = Math.floor(Board.divide / 2);
          break;
        case 1:
          start.x = 25;
          start.y = Math.floor(Board.divide * 1.5);
          ended.x = Board.canvas.width - 25;
          ended.y = Math.floor(Board.divide * 1.5);
          break;
        case 2:
          start.x = 25;
          start.y = Math.floor(Board.divide * 2.5);
          ended.x = Board.canvas.width - 25;
          ended.y = Math.floor(Board.divide * 2.5);
          break;
        case 3:
          start.x = Math.floor(Board.divide / 2);
          start.y = 25;
          ended.x = Math.floor(Board.divide / 2);
          ended.y = Board.canvas.height - 25;
          break;
        case 4:
          start.x = Math.floor(Board.divide * 1.5);
          start.y = 25;
          ended.x = Math.floor(Board.divide * 1.5);
          ended.y = Board.canvas.height - 25;
          break;
        case 5:
          start.x = Math.floor(Board.divide * 2.5);
          start.y = 25;
          ended.x = Math.floor(Board.divide * 2.5);
          ended.y = Board.canvas.height - 25;
          break;
        case 6:
          start.x = 25;
          start.y = 25;
          ended.x = Board.canvas.width - 25;
          ended.y = Board.canvas.height - 25;
          break;
        case 7:
          start.x = 25;
          start.y = Board.canvas.height - 25;
          ended.x = Board.canvas.width - 25;
          ended.y = 25;
      }
      context.beginPath();
      context.moveTo(start.x, start.y);
      context.strokeStyle = 'rgba(255, 105, 180, 0.2)';
      context.lineWidth = Const.RED_LINE_WIDTH;
      newX = start.x + (ended.x - start.x) * Board.amount;
      newY = start.y + (ended.y - start.y) * Board.amount;
      context.lineTo(newX, newY);
      context.stroke();
      if (newX === ended.x && newY === ended.y) {
        cancelRequestAnimFrame(Board.request);
        Board.request = null;
        return Board.amount = 0;
      }
    };

    Board.display = function(board, overflg) {
      var context, i, j, ref, x, y;
      if (overflg !== 0) {
        Board.animate();
      }
      if (!((Board.statusarea.innerHTML === Const.INITIALIZING_MSG) || (Board.statusarea.innerHTML === Const.RESTART_MSG))) {
        Board.statusarea.innerHTML = (function() {
          switch (board.teban) {
            case Const.NOUGHT:
              return "◯の番";
            case Const.CROSS:
              return "×の番";
            default:
              return "";
          }
        })();
      }
      context = Board.canvas.getContext('2d');
      context.beginPath();
      context.fillStyle = "#2f4f4f";
      context.fillRect(0, 0, Board.canvas.width, Board.canvas.height);
      context.strokeStyle = "rgb(255, 255, 255)";
      context.lineWidth = Const.LINE_WIDTH;
      context.moveTo(Board.divide, 0);
      context.lineTo(Board.divide, Board.canvas.height);
      context.moveTo(Board.divide * 2, 0);
      context.lineTo(Board.divide * 2, Board.canvas.height);
      context.moveTo(0, Board.divide);
      context.lineTo(Board.canvas.width, Board.divide);
      context.moveTo(0, Board.divide * 2);
      context.lineTo(Board.canvas.width, Board.divide * 2);
      for (i = j = 0, ref = board.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        x = Board.divide * (i % 3);
        y = Board.divide * Math.floor(i / 3);
        if (board[i] === Const.NOUGHT) {
          context.moveTo(x + Board.divide, y + Board.radius);
          context.arc(x + Board.radius + 2, y + Board.radius, Board.radius - 5, 0, Math.PI * 2, false);
        } else if (board[i] === Const.CROSS) {
          context.moveTo(x + 10, y + 10);
          context.lineTo(x + Board.divide - 10, y + Board.divide - 10);
          context.moveTo(x + Board.divide - 10, y + 10);
          context.lineTo(x + 10, y + Board.divide - 10);
        }
      }
      return context.stroke();
    };

    Board.init = function(board) {
      var context, i, j, ref;
      Board.lineno = null;
      Board.divide = Board.canvas.width / 3;
      Board.radius = Board.divide / 2;
      board.teban = null;
      for (i = j = 0, ref = board.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        board[i] = null;
      }
      context = Board.canvas.getContext('2d');
      return context.clearRect(0, 0, Board.canvas.width, Board.canvas.height);
    };

    function Board(args, teban, move) {
      var i, j, ref;
      if (args == null) {
        args = [null, null, null, null, null, null, null, null, null];
      }
      if (teban == null) {
        teban = null;
      }
      if (move == null) {
        move = null;
      }
      this.clone = bind(this.clone, this);
      for (i = j = 0, ref = args.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        this.push(args[i]);
      }
      this.teban = teban;
      this.move = move;
      Board.canvas = document.getElementById("canvasMain");
      Board.statusarea = document.getElementById("spanStatus");
    }

    Board.prototype.clone = function() {
      return new this.constructor(this, this.teban, this.move);
    };

    Board.prototype.wonorlost = function() {
      var i, j, len, line, piece, ref;
      ref = Board.lines;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        line = ref[i];
        piece = this[line[0]];
        if (piece && piece === this[line[1]] && piece === this[line[2]]) {
          Board.lineno = i;
          return piece;
        }
      }
      if (indexOf.call(this, null) >= 0) {
        return null;
      }
      return 0;
    };

    return Board;

  })(Array);

  Player = (function() {
    function Player(sengo) {
      this.sengo = sengo != null ? sengo : Const.CROSS;
      this.trees = null;
      this.duplication = {};
      this.initializing = false;
      this.p_status = null;
      this.statusarea = document.getElementById("spanStatus");
      this.progressBar = document.getElementById("progressbar");
      this.spanCount = document.getElementById("spanCount");
      this.startbtn = document.getElementById("btnStart");
      this.labelprogress = document.getElementById("trees");
    }

    Player.prototype.init_dup = function() {
      return this.duplication = {};
    };

    Player.prototype.check_dup = function(board) {
      var buf, i, j, key, len, len1, m, ref, temp, v, value;
      temp = board.clone();
      ref = Board.rotate_sym;
      for (j = 0, len = ref.length; j < len; j++) {
        v = ref[j];
        buf = new Array(Const.BOARD_SIZE);
        for (i = m = 0, len1 = temp.length; m < len1; i = ++m) {
          value = temp[i];
          buf[v[i]] = value;
        }
        for (key in this.duplication) {
          if (key === buf.toString()) {
            return true;
          }
        }
      }
      if (this.check(temp)) {
        return true;
      }
      return false;
    };

    Player.prototype.set_dup = function(board) {
      var seed;
      seed = board.clone();
      return this.duplication[seed.toString()] = board;
    };

    Player.prototype.learning = function(result, history) {
      var base, board, buf, converted, dose, e, inc, positive, pre_index, restore_index, ret, storageSize;
      board = history.pop();
      pre_index = board.move;
      base = history.length;
      while (board != null) {
        dose = history.length / base;
        switch (result) {
          case Const.CROSS:
            inc = this.sengo === Const.CROSS ? 3.0 * dose : -1.0 * dose;
            break;
          case Const.DRAW:
            inc = 1.0;
            break;
          case Const.NOUGHT:
            inc = this.sengo === Const.NOUGHT ? 3.0 * dose : -1.0 * dose;
            break;
          default:
            console.log("Error in Player.learning");
        }
        board = history.pop();
        ret = this.trees.search(board);
        if (ret != null) {
          buf = ret[0];
          converted = ret[1];
        } else {
          buf = null;
          converted = 0;
        }
        restore_index = Board.restore_table[converted];
        if (buf != null) {
          if (this.sengo === buf.value.teban) {
            buf.score[Board.rotate_sym[restore_index][pre_index]] += inc;
          }
          if (buf.score[Board.rotate_sym[restore_index][pre_index]] <= 0.1) {
            positive = Math.min.apply(this, buf.score);
            positive = positive != null ? Math.abs(positive) + Const.PEBBLES : Const.PEBBLES;
            buf.score = buf.score.map(function(i) {
              if (i !== null) {
                return i + positive;
              } else {
                return null;
              }
            });
          }
          pre_index = board.move;
        } else {
          if (buf === null && history.length !== 0) {
            this.statusarea.innerHTML = Const.DATA_NO_NODE;
          }
        }
      }
      try {
        localStorage.setItem("SerializedData", JSON.stringify(this.trees));
      } catch (error) {
        e = error;
        storageSize = Math.round(JSON.stringify(localStorage).length / 1024);
        console.log("Limit Reached: " + storageSize + "K");
        console.log(e);
        this.statusarea.innerHTML = Const.DATA_LEARN_WRITE_ERROR;
        return false;
      }
      return this.p_status = null;
    };

    Player.prototype.prepare = function() {
      this.labelprogress.style.display = "block";
      if (!this.initializing) {
        this.bfs_chunk(0);
      }
      this.initializing = true;
    };

    Player.prototype.bfs_chunk = function(seq, queue) {
      var b, bar, board, buf, e, i, j, layer, len, len1, m, ret, temp;
      if (queue == null) {
        queue = [];
      }
      if (seq === 0) {
        this.init_dup();
        board = new Board([null, null, null, null, null, null, null, null, null]);
        board.teban = Const.CROSS;
        this.trees = new Tree(board);
        this.set_dup(board);
        queue.push(board);
      }
      if (queue.length !== 0) {
        buf = queue.shift();
        layer = 0;
        for (i = j = 0, len = buf.length; j < len; i = ++j) {
          b = buf[i];
          if (b != null) {
            layer += 1;
          }
        }
        for (i = m = 0, len1 = buf.length; m < len1; i = ++m) {
          b = buf[i];
          if (b != null) {
            continue;
          }
          temp = buf.clone();
          temp[i] = buf.teban;
          temp.move = null;
          if (this.check_dup(temp)) {
            continue;
          }
          seq += 1;
          bar = (seq / Const.ALL_NODES) * 100;
          switch (layer) {
            case 0:
              this.trees.child.push(new Tree(temp));
              break;
            default:
              ret = this.trees.add(buf, new Tree(temp));
          }
          temp.teban = buf.teban === Const.CROSS ? Const.NOUGHT : Const.CROSS;
          this.set_dup(temp);
          queue.push(temp);
          this.statusarea.innerHTML = Const.INITIALIZING_MSG;
        }
        setTimeout(((function(_this) {
          return function() {
            _this.bfs_chunk(seq, queue);
            if (temp != null) {
              return Board.display(temp);
            }
          };
        })(this)), 0);
      } else {
        bar = 100;
        this.startbtn.disabled = false;
        this.labelprogress.style.display = "none";
        this.statusarea.innerHTML = Const.RESTART_MSG;
        try {
          localStorage.setItem("Initialized", true);
          localStorage.setItem("SerializedData", JSON.stringify(this.trees));
        } catch (error) {
          e = error;
          console.log(e);
        }
      }
      if (bar != null) {
        this.progressBar.value = Math.floor(bar);
      }
      if (bar != null) {
        this.spanCount.innerHTML = Math.floor(bar);
      }
    };

    Player.prototype.check = function(board) {
      var j, l, len, piece, ref;
      if (!(indexOf.call(board, null) >= 0)) {
        return true;
      }
      ref = Board.lines;
      for (j = 0, len = ref.length; j < len; j++) {
        l = ref[j];
        piece = board[l[0]];
        if ((piece != null) && piece === board[l[1]] && piece === board[l[2]]) {
          return true;
        }
      }
      return false;
    };

    return Player;

  })();

  Game = (function() {
    function Game() {
      var special_event;
      this.board = new Board([null, null, null, null, null, null, null, null, null]);
      this.man_player = new Player(Const.CROSS);
      this.cpu_player = new Player(Const.NOUGHT);
      this.canvasImage = document.getElementById("canvasImage");
      this.startbtn = document.getElementById("btnStart");
      this.statisticsbtn = document.getElementById("btnStatistics");
      this.statusarea = document.getElementById("spanStatus");
      this.win_count = document.getElementById("spanWin");
      this.lose_count = document.getElementById("spanLose");
      this.draw_count = document.getElementById("spanDraw");
      this.img_percentage = document.getElementById("spanPercentage");
      special_event = typeof cordova === "undefined" ? "DOMContentLoaded" : "deviceready";
      this.setEventListener(special_event);
      this.status = null;
      this.history = [];
      this.init();
    }

    Game.prototype.encrypt = function(src, key) {
      var enc, encrypted, i, j, ref;
      encrypted = [];
      for (i = j = 0, ref = src.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        enc = src.charCodeAt(i) ^ key.charCodeAt(i);
        encrypted.push(enc);
      }
      return encrypted;
    };

    Game.prototype.init = function() {
      var data, e, err, initialFlg, src;
      initialFlg = localStorage.getItem("Initialized");
      if (initialFlg != null) {
        data = localStorage.getItem("SerializedData");
        if (data != null) {
          try {
            src = JSON.parse(data);
            this.cpu_player.trees = Tree.deserialize(src);
          } catch (error) {
            e = error;
            this.statusarea.innerHTML = Const.DATA_READ_ERROR;
            console.log(e);
          }
        } else {
          this.statusarea.innerHTML = Const.DATA_READ_ERROR;
        }
      }
      try {
        this.win_count.innerHTML = localStorage.getItem("win_count");
        this.lose_count.innerHTML = localStorage.getItem("lose_count");
        return this.draw_count.innerHTML = localStorage.getItem("draw_count");
      } catch (error) {
        err = error;
        console.log("=== Error ===");
        console.log(err);
        this.win_count.innerHTML = "0";
        this.lose_count.innerHTML = "0";
        return this.draw_count.innerHTML = "0";
      }
    };

    Game.prototype.btnstatistics = function(target) {
      var degree, enc, enc_str, ret;
      if (this.cpu_player.trees != null) {
        this.img_percentage.innerHTML = "";
        Tree.total = 0;
        Tree.pebbles = 0;
        ret = this.cpu_player.trees.statistics_prevent();
      } else {
        ret = null;
      }
      if ((ret != null) && ret[0] >= 1) {
        degree = Math.round(ret[1] / ret[0] * 100000) / 1000;
        switch (true) {
          case degree <= 23:
            enc = this.encrypt("0", Const.IMG_SEED);
            break;
          case degree <= 25:
            enc = this.encrypt("1", Const.IMG_SEED);
            break;
          case degree <= 27:
            enc = this.encrypt("2", Const.IMG_SEED);
            break;
          case degree <= 30:
            enc = this.encrypt("3", Const.IMG_SEED);
            break;
          case degree <= 33:
            enc = this.encrypt("4", Const.IMG_SEED);
            break;
          case degree <= 37:
            enc = this.encrypt("5", Const.IMG_SEED);
            break;
          case degree <= 41:
            enc = this.encrypt("6", Const.IMG_SEED);
            break;
          case degree <= 46:
            enc = this.encrypt("7", Const.IMG_SEED);
            break;
          case degree <= 51:
            enc = this.encrypt("8", Const.IMG_SEED);
            break;
          case degree <= 56:
            enc = this.encrypt("9", Const.IMG_SEED);
            break;
          case degree <= 61:
            enc = this.encrypt("10", Const.IMG_SEED);
            break;
          case degree <= 66:
            enc = this.encrypt("11", Const.IMG_SEED);
            break;
          case degree <= 72:
            enc = this.encrypt("12", Const.IMG_SEED);
            break;
          case degree <= 78:
            enc = this.encrypt("13", Const.IMG_SEED);
            break;
          case degree <= 84:
            enc = this.encrypt("14", Const.IMG_SEED);
            break;
          case degree > 84:
            enc = this.encrypt("15", Const.IMG_SEED);
            break;
          default:
            enc = this.encrypt("0", Const.IMG_SEED);
        }
        this.img_percentage.innerHTML = ":" + degree.toString() + " %";
        enc_str = enc.join(",");
        return localStorage.setItem(Const.IMG_INDEX, enc_str);
      } else {
        return this.img_percentage.innerHTML = "0%";
      }
    };

    Game.prototype.btnstart = function(target) {
      var idx, initialFlg, locate;
      if (this.cpu_player.p_status) {
        console.log("not ending");
        return;
      }
      if (Board.request != null) {
        cancelRequestAnimFrame(Board.request);
      }
      this.history = [];
      Board.init(this.board);
      this.board.move = null;
      this.history.push(this.board.clone());
      initialFlg = localStorage.getItem("Initialized");
      if (initialFlg == null) {
        this.cpu_player.prepare();
        return;
      }
      idx = Math.floor(Math.random() * 2);
      if (idx === 0) {
        this.man_player.sengo = Const.NOUGHT;
        this.cpu_player.sengo = Const.CROSS;
      } else {
        this.man_player.sengo = Const.CROSS;
        this.cpu_player.sengo = Const.NOUGHT;
      }
      if (this.cpu_player.sengo === Const.CROSS) {
        locate = this.cpu_player.trees.apply(this.board);
        this.board[locate] = Const.CROSS;
        this.board.teban = Const.NOUGHT;
        this.board.move = locate;
        this.history.push(this.board.clone());
      } else {
        this.board.teban = Const.CROSS;
      }
      this.prepared();
      return Board.display(this.board, 0);
    };

    Game.prototype.touch = function(target, clientX, clientY) {
      var clickX, clickY, judge, locate;
      if (this.status == null) {
        console.log("cancel");
        return;
      }
      clickX = Math.floor((clientX - target.context.offsetLeft) / Board.divide);
      clickY = Math.floor((clientY - target.context.offsetTop) / Board.divide);
      locate = clickX + clickY * 3;
      if (this.board[locate] !== null) {
        console.log("not null");
        return;
      }
      this.board[locate] = this.man_player.sengo;
      this.board.teban = this.cpu_player.sengo;
      this.board.move = locate;
      this.history.push(this.board.clone());
      judge = this.board.wonorlost();
      Board.display(this.board, judge);
      if (judge != null) {
        this.gameover(judge);
        this.cpu_player.learning(judge, this.history);
      } else {
        setTimeout(((function(_this) {
          return function() {
            var event;
            event = new $.Event('cputhinking');
            return $(window).trigger(event);
          };
        })(this)), 0);
      }
    };

    Game.prototype.setCanvasSize = function(w, h) {
      if (w <= h) {
        Board.canvas.width = w * 0.85;
        Board.canvas.height = w * 0.85;
        this.canvasImage.width = w * 0.85;
        this.canvasImage.height = w * 0.85;
      } else {
        Board.canvas.width = h * 0.85;
        Board.canvas.height = h * 0.85;
        this.canvasImage.width = h * 0.85;
        this.canvasImage.height = h * 0.85;
      }
    };

    Game.prototype.setEventListener = function(special) {
      $(window).on('cputhinking', (function(_this) {
        return function(e) {
          var judge, locate;
          locate = _this.cpu_player.trees.apply(_this.board);
          if (locate == null) {
            _this.statusarea.innerHTML = Const.DATA_ERROR;
          }
          _this.board[locate] = _this.cpu_player.sengo;
          _this.board.teban = _this.man_player.sengo;
          _this.board.move = locate;
          _this.history.push(_this.board.clone());
          judge = _this.board.wonorlost();
          Board.display(_this.board, judge);
          if (judge != null) {
            _this.gameover(judge);
            _this.cpu_player.learning(judge, _this.history);
          }
        };
      })(this));
      $('#canvasMain').on('click', (function(_this) {
        return function(e) {
          var target;
          target = $(e.currentTarget);
          return _this.touch(target, e.clientX, e.clientY);
        };
      })(this));
      $('#btnStart').on('click', (function(_this) {
        return function(e) {
          var target;
          target = $(e.currentTarget);
          return _this.btnstart(target);
        };
      })(this));
      $('#btnStatistics').on('click', (function(_this) {
        return function(e) {
          var target;
          target = $(e.currentTarget);
          return _this.btnstatistics(target);
        };
      })(this));
      $(window).on('load', (function(_this) {
        return function(e) {
          var target;
          target = $(e.currentTarget);
          _this.setCanvasSize(target.width(), target.height());
          Board.divide = Board.canvas.width / 3;
          Board.radius = Board.divide / 2;
          Board.display(_this.board, 0);
          return $('body').pointer({
            'divide': Board.divide
          });
        };
      })(this));
      return $(window).on(special, (function(_this) {
        return function(e) {
          var target;
          return target = $(e.currentTarget);
        };
      })(this));
    };

    Game.prototype.outputRecord = function(winner) {
      var draw_count, err, lose_count, win_count;
      try {
        win_count = parseInt(localStorage.getItem("win_count"), 10);
        lose_count = parseInt(localStorage.getItem("lose_count"), 10);
        draw_count = parseInt(localStorage.getItem("draw_count"), 10);
        if (!win_count) {
          win_count = 0;
        }
        if (!lose_count) {
          lose_count = 0;
        }
        if (!draw_count) {
          return draw_count = 0;
        }
      } catch (error) {
        err = error;
        console.log(err);
        win_count = 0;
        lose_count = 0;
        return draw_count = 0;
      } finally {
        if (this.man_player.sengo === winner) {
          win_count += 1;
          localStorage.setItem("win_count", win_count);
        } else {
          if (this.cpu_player.sengo === winner) {
            lose_count += 1;
            localStorage.setItem("lose_count", lose_count);
          } else {
            draw_count += 1;
            localStorage.setItem("draw_count", draw_count);
          }
        }
        this.init();
      }
    };

    Game.prototype.gameover = function(winner) {
      var msg;
      this.startbtn.disabled = false;
      msg = (function() {
        switch (winner) {
          case Const.CROSS:
            return "×の勝ち";
          case Const.NOUGHT:
            return "◯の勝ち";
          case Const.DRAW:
            return "引き分け";
          default:
            return "";
        }
      })();
      this.statusarea.innerHTML = msg;
      this.outputRecord(winner);
      this.cpu_player.p_status = true;
      return this.status = null;
    };

    Game.prototype.prepared = function() {
      this.statusarea.innerHTML = "";
      this.status = true;
      return this.startbtn.disabled = true;
    };

    return Game;

  })();

  window.Game = window.Game || Game;

  window.requestAnimFrame = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
      return window.setTimeout(callback, 0);
    };
  })();

  window.cancelRequestAnimFrame = (function() {
    return window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout;
  })();

}).call(this);

//# sourceMappingURL=tictactoe.js.map
